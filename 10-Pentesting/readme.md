
# This reposity has been abandoned. Please see https://ccss17.github.io/security-tutorial

# 이 레포지토리는 더 이상 관리되지 않습니다. https://ccss17.github.io/security-tutorial 에 방문해주세요.

# 마무리 + 침투테스트 

## 보완과 파훼의 끝없는 악순환 

익스플로잇을 하면서 BOF 취약점과 그것을 막기 위한 NX 비트, 그리고 그것의 파훼법인 RTL, 또 RTL 을 막기 위한 ASLR 그리고 그 ASLR 을 파훼하는 방법을 간단하게 배워봤어요. 

이런 식으로 해킹 기법이 개발되고 그것을 막는 보안 기법이 개발되고 그럼 그걸 또 파훼하는 해킹 기법이 개발되고 그러면 또 그것을 막기 위한 보안 기법이 개발되고 과거로부터 이런 악순환이 계속 반복되고 있습니다. 

BOF 취약점은 가장 기초적인 취약점이지만 1970 년대에 발견된 취약점입니다. 그리고 ASLR 이나 NX 비트는 2000년대 초반에 개발된 보안 기법이라고 해요. 그러니까 지금 여러분의 보안 지식은 1970년대에서 2000년대 초반정도에 머물고 있는 거죠. 그래서 보안 공부를 한다는 것은 이 **보완과 파훼의 순환 고리** 가 어디까지 진행되었는지 이해하는 것이고, 만약 이 악순환의 싸이클이 2019년 현재까지 어떻게 이어져왔는지 모두 다 공부한다면 그때부터는 여러분이 이 싸이클을 만들어 나가는 사람들이 될 수 있는 거겠죠? 화이트 해커가 되었다면 보완 이라는 순환 고리를 만들 것이고 블랙 해커가 되었다면 그것을 파훼하는 순환 고리를 만들어나가기 시작하겠죠. 그러면 이제 막 공부를 시작하는 사람들은 여러분들이 만든 보완 기법 또는 해킹 기법을 배우게 될 수도 있죠.

여러분은 이 악순환의 두 싸이클만 배운거 라고 할 수 있겠네요. 보완하고 파훼하고 보완하고 파훼하고 이렇게 두 싸이클만 배운거죠. 하지만 지금 해킹과 보안의 최전방, 그러니까 실전으로 가게 되면 역사적으로 있어왔던 모든 해킹 기법과 모든 보안 기법, 그러니까 그 보완과 파훼의 싸이클을 다 알고 있는 사람들끼리 싸우고 있겠죠. 그쵸?

그렇기 때문에 보안 공부를 한다는 건 기본적으로는 세상에 알려진 모든 보안 기법과 해킹 기법들의 싸이클을 이해하는 것이고 그 싸이클들을 다 이해하다보면 언젠가 실전으로 가게 되겠죠. 그 싸이클을 "파훼든" "보완이든" 실전으로 만들고 있는 사람들 곁으로 따라갈 수 있을 거에요. 즉 화이트 해커가 되든 블랙 해커가 되든..

### 보안 패치의 의미 

여러분 스마트폰 보면 가끔 패치하죠? 컴퓨터 윈도우 쓸 때도 윈도우 업데이트 하죠. 그 패치 하나 하나가 보완 싸이클이에요. 해킹 기법이 개발되서 그것을 보완하는 하나의 싸이클입니다. 그러니까 보안 업데이트 잘하셔야 합니다. 

결론적으로 만약 여러분이 어떤 서버의 보안을 책임져야 하는 상황이 왔다고 하면 어떻게 해야 할까요? 그 시스템을 2019년의 보안 시스템으로 만들어야죠. 그러니까 지금까지 개발된 모든 보안 기법을 하나도 빠짐없이 전부 다 적용해야죠. 그러면 일단은 모든 책임을 다 한 겁니다. 제로데이 취약점으로 공격받으면 어쩔 수 없죠. 제로데이는 모든 보안 기법을 파괴하는 가장 최신의 파훼 싸이클이라고 할 수 있으니까요. 기본적으로는 제로데이를 모르는 것은 책임이 되지 않죠. 어쩔 수 없으니까. 하지만 그렇다고 해서 손 놓고 있을 수는 없으니까 구글 프로젝트 제로나 아미스나 짐페리온 같은 화이트 해커들이 지금도 제로데이를 찾으려고 애쓰고 있는 거죠. 

### 악순환의 끝 

> 이 부분은 팩트가 아닌 주관적 의견임 

하지만 이 악순환을 누구든 끝내버리고 싶어해요. 매듭을 지어버리고 싶어 합니다. 블랙 해커들은 끊임없이 보안을 강화해서 자신들의 해킹 기법을 무력화시키는 악순환을 끊어버리고 싶어 하겠고, 화이트 해커들은 자신들의 보안 기법들을 무력화시키는 해킹 기법들의 악순환을 끊어버리고 싶어하죠. 

그 악순환을 끊을 수 있는 방법은 상대방 보다 압도적으로 높은 기술력을 갖는 겁니다. 블랙 해커라면 화이트 해커가 막을 수 없을 정도의 강력한 해킹 기술로, 화이트 해커라면 블랙 해커가 침투할 수 없을 정도의 강력한 보안 기술을 원하겠죠. 

그런데 해킹 기술이나 보안 기술을 사람이 학습하고 사람이 발전시키도록 하면 이제까지와 다른 것이 전혀 없죠. 하지만 인공지능을 사용하면 사람보다 훨씬 빠른 속도로 모든 것을 학습할 수 있고 발전시킬 수 있어요. 게다가 사람은 보안이나 해킹을 어느정도 연구하고 쉬기도 해야 하고 자기도 해야 하는데, 인공지능은 24시간 연구를 하고 발전을 시킬 수 있어요. 그래서 앞으로는 인공지능 시대죠. 보안도 인공지능으로, 해킹도 인공지능으로. 

## 침투 테스트 (Penetration test)

https://en.wikipedia.org/wiki/Penetration_test

펜 테스트라고도 불리는 침투 테스트란 허가된 컴퓨터 시스템에 대한 사이버 공격을 시뮬레이션하는 것이다. 기업 입장에서는 펜테스트가 취약점을 확인하는데에 도움이 되고 보안을 공부하는 입장에서는 취약점을 실질적으로 익스플로잇 해보고 취약점을 보완해봄으로써 많은 공부가 될 수 있다. 

정석적으로는 타겟 시스템이 먼저 있고, 그 시스템에 대한 모든 정보를 확인해서 시스템의 취약점을 확인한 후에 여러가지 방법으로 침투를 테스트 할 수 있다. 예를 들어서 어떤 회사가 **Ubuntu 16.04** 운영체제를 **x86_64** 아키텍쳐 위에서 사용하고 있고 **apache 2.4** 를 통해서 **Wordpress 0.7** 버전을 사용하고 있다고 하자. 그러면 해당되는 버전에 존재하는 모든 취약점을 알아낸 후 침투 해보는 테스트를 할 수 있다.

하지만 보안을 공부하는 학생 입장에서는 타겟 시스템이 먼저 있는 것이 아니라 테스트 해보고 싶은 취약점이 먼저이다. 

[most critical vulnerabilities 2019](https://www.google.co.kr/search?q=most+critical+vulnerabilities+2019&oq=most+critical+vulnerabilities+2019&aqs=chrome..69i57.4358j0j9&sourceid=chrome&ie=UTF-8)

[web vulnerabilities 2019](https://www.google.co.kr/search?ei=joYxXdTQJ7SWr7wPooiwoAE&q=web+vulnerabilities+2019&oq=web+&gs_l=psy-ab.3.0.35i39l2j0i67l6j0l2.36393.36868..37781...0.0..0.180.589.0j4......0....1..gws-wiz.......0i71j0i20i263.tHrk0qxNnLs)

[android vulnerabilities 2019](https://www.google.co.kr/search?q=android+vulnerabilities+2019&oq=android+vulnerabilities+2019&aqs=chrome.0.0j69i65j0l4.3604j0j9&sourceid=chrome&ie=UTF-8)

이런 식으로 검색해보면서 어떤 취약점이 발생했었나 확인해 볼 수 있다. 

### CVE-2018-3774 펜테스팅 흐름 예시 

그러다가 CVE-2018-3774 라는 Node.js 서드파티 모듈 url-parse 에서 발생한 취약점이 있다는 것을 알게 되고 펜테스팅을 해보고 싶다는 생각이 들었다고 해보자. 

그러면 먼저 CVE 홈페이지에서 원본 글을 확인해볼 수 있다. 

(CVE-2018-3774)[https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2018-3774]

**Desciption** 을 보면서 npm 자바스크립트 패키지 1.4.3 미만의 버전에서 나타나는 **잘못된 호스트 네임 반환 취약점** 이라는 것을 알 수 있었다. 그리고 이 취약점으로 **오픈 리다이렉트(Open Redirect)** 공격이 가능하게 된다고 한다. 잘못된 호스트 네임 반환 취약점과 오픈 리다이렉트에 대해서 좀 더 알아봐야 할 것 같다. 

#### 잘못된 호스트 네임 반환에 대한 이해 

**References** 를 보면 다음과 같은 링크들이 있었다.

https://github.com/unshiftio/url-parse/commit/53b1794e54d0711ceb52505e0f74145270570d5a

https://github.com/unshiftio/url-parse/commit/d7b582ec1243e8024e60ac0b62d2569c939ef5de

https://hackerone.com/reports/384029

내용들 중에 **SegfaultMasters** 라는 유저가 이 취약점을 테스트해본 코드를 공유해놓은 것을 발견해서 이것을 테스트 해보기로 한다. 

```javascript
'use strict';
var URL = require('url-parse');
var url = new URL('http://google.com:80%5c%5cyahoo.com//#what\\is going on');
console.log(url.hostname);
```

먼저 url-parse 라는 npm 패키지를 1.4.3 미만의 버전으로 설치해본다. 

```shell
npm i url-parse@1.4.0
```

그리고 방금 전 소스를 `test.js` 에 저장하고 실행해본다. `google.com:80%5c%5cyahoo.com` 이런 출력이 나왔는데 아직 감이 안온다. 커밋의 `diff` 를 조금 살펴보니 다음과 같이 조작된 URL 이 있었다.

```javascript
var url = 'http://google.com:80\\@yahoo.com/#what\\is going on'
```

이 URL 을 사용해서 다시 코드를 실행해본다.


```javascript
'use strict';
var URL = require('url-parse');
var url = new URL('http://google.com:80//@yahoo.com//#what\\is going on');
console.log(url.hostname);
```

출력 결과는 놀랍게도 `yahoo.com` 이었다. 호스트 네임은 분명 **google.com** 이지만 **//@** 이라는 문자열이 들어갔을 때 파싱 에러가 발생해서 **yahoo.com** 이 반환된다. 좀 더 확신을 얻기 위해 다음과 같이 소스를 조금만 수정해서 다시 실험해본다. 

```javascript
'use strict';
var URL = require('url-parse');
var url = new URL('https://hisnet.handong.edu');
console.log(url.hostname);
var url = new URL('https://hisnet.handong.edu\\@ghostogether.club');
console.log(url.hostname);
```

출력 결과는 다음과 같았다.

```javascript
λ  urlparse-test node test.js
hisnet.handong.edu
ghostogether.club
```

이쯤 되니 **잘못된 호스트 네임 반환 취약점** 이 어떤 뜻인지 이해할 수 있었다. 그러면 이제 **오픈 리다이렉트(Open Redirect)** 취약점이 무엇인지 궁금해졌다. 

#### 오픈 리다이렉트(Open Redirect) 취약점에 대한 이해 

오픈 리다이렉트에 대한 설명은 구글링을 조금만 해보니 곧 바로 알 수 있었다. 이 공격 및 취약점은 파라미터가 리다이렉트 URL 로 사용될 때 발생하는 취약점이었다. 

보통 어떤 사이트에 접속하려 할 때 접근 권한이 필요해서 로그인 창으로 리다이렉트 될 때가 있다. 그때 웹 서버가 URL 의 파라미터에 리다이렉트 URL 을 명시하였을 때, 그 리다이렉트 URL 을 악성 코드를 실행시킬 수 있는 서버의 URL 로 설정하고 사람들에게 클릭하게 만드는 공격법이었다.

`http://example.com/login.php?url=http://malicious.com`

그러면 사람들은 **example.com** 만 보고 안전한 사이트라 생각하고 아이디와 비밀번호를 입력하지만 실제로는 **malicious.com** 으로 리다이렉트 된다. 

#### Pentesting 

이 취약점에 대한 이해와 이 취약점이 오픈 리다이렉트 공격으로 활용될 수 있다는 것을 이해하였기 때문에 곧바로 침투테스트를 해볼 수 있었다. 

```javascript
// test2.js
‘use strict’;
var URL = require(‘url-parse’);
const express = require(‘express’)
const app = express()
app.get(‘/’, (req, res) => {
    console.log(new URL(req.query[‘url’]).host)
})
app.listen(8080)
```

위와 같이 `express` 웹 서버를 사용하여 간단하게 로컬에서 웹 서버를 열고 **url** 파라미터에 삽입되는 데이터를 취약한 패키지인 **url-parse** 를 사용하여 호스트 네임을 파싱해보았다. 

`http://localhost:8080/\?url=http://hisnet.handong.edu`

위와 같은 URL 로 접속해보았을 때 웹 서버가 **hisnet.handong.edu** 을 출력했다. 

`http://localhost:8080/\?url=http://hisnet.handong.edu\\@ghostogether.club`

하지만 위와 같은 URL 로 접속해보니까 **ghostogether.club** 이 출력되었다. 이 경우 **ghostogether.club** 이 악성 코드를 실행 시킬 수 있는 웹 페이지라도 사람들은 **hisnet.handong.edu** 만 보고 클릭을 할 것이다. _클릭 안 할것 같죠? 다 클릭 합니다. 한동대 피싱 페이지사건도 있었잖아요._

그러면 이 취약점으로 어떻게 공격되는 것을 이해 했으니 침투테스트를 마무리했다. 이 시점에서 화이트 해커는 이것을 패치하라고 권유할 것이고 블랙 해커는 이 침투 테스트 경험을 활용해서 해킹을 시도할 것이다. 즉 침투 테스트, 즉 펜테스팅까지는 착한 사람이나 나쁜 사람이나 다 한다. 

### CVE-2017-0785 펜테스팅 흐름 예시 

[Armis-BlueBorne-Android-Exploit-WP.pdf](Armis-BlueBorne-Android-Exploit-WP.pdf)

[BlueBorne Technical White Paper_20171130.pdf](BlueBorneTechnicalWhitePaper_20171130.pdf)

이 취약점은 영향력이 컸던 블루투스 취약점으로써 CVE 홈페이지를 확인해볼 수도 있지만, 영향력이 컸던 만큼 원작자가 취약점에 대한 상세한 문서와 POC 코드를 제공하였고 많은 블로거들이 이 취약점에 대한 포스트를 제공하였다. 그래서 여러가지 문서를 통해서 이 취약점에 대해서 이해할 수 있었고 침투 테스트를 할 수 있었다.

다만 이 취약점은 특정 안드로이드 버전에서 발생한 취약점이기 때문에 안드로이드 가상 머신이나 취약한 버전의 공기계가 필요했다. 

### CVE-2017-5754 펜테스팅 흐름 예시 

[meltdown.pdf](meltdown.pdf)

이 취약점은 IT 업계에 막대한 영향력을 끼친 CPU 취약점이었다. 영향력이 컸던 만큼 원작자, **Project Zero** 팀과 많은 블로거들이 포스팅을 남겼지만 취약한 CPU 가 있어야 했기에 펜테스팅을 해볼 수는 없었다. 

### 취약점 설명 자료

- [고스트 OB 모임 발표 자료](last.pdf) : 블루투스 취약점, 멜트다운 취약점에 대한 설명자료 

- https://ccss17.github.io/paper/blueborne/

- https://ccss17.github.io/paper/meltdown/

### 침투 테스트 결론

어쨌든 이렇게 펜테스팅을 하려면 취약점에 해당되는 버전의 제품이 있어야 한다. 그 제품이 CPU 일수도, 운영체제일 수도, 프레임워크일 수도 있다. 그런 다음 해당 취약점의 정보를 수집해서 취약점을 이해한 후 익스플로잇을 시도하는 것이 전부 다이다. 